\chapter{$\symBSPsweep$}
\label{hoofdstuk:bsp-sweep}
In dit hoofdstuk wordt een nieuwe soort $\symBSP$ boom besproken: de $\symBSPsweep$ boom.
Eerst wordt het algemene idee besproken en nadien een aantal specifieke versies van de $\symBSPsweep$.

% Duidelijk wiskundig uitleggen

 % TODO
 % Beginnen met het probleem te schetsen, aantal paragrafen aan spenderen: 
%  	- Eerst uitleggen in welke gevallen het nuttig is dat je die vrijheid gebruikt
%	- In dit soort scene, intuitief ...

\section{Probleemstelling}
    Het doel van acceleratiestructuren is om de totale kost om een scene te renderen, te minimaliseren.
    Deze rendertijd $\symTime_{\symRender}$ bestaat uit twee grote factoren: de tijd gespendeerd aan het intersecteren met driehoeken (de intersectietijd) en de tijd gespendeerd aan het doorkruisen van de boom (de doorkruistijd).
    De totale intersectietijd $\symTime_{\symIntersection, \symTotal}$ is afhankelijk van het aantal driehoeken $\symNbPrimitives_\symLeaf$ in de geïntersecteerde bladknopen $\symLeaf$ en het aantal keer $\symTraversalL_\symLeaf$ dat elk van deze bladknopen doorkruist wordt.
    De totale doorkruistijd $\symTime_{\symTraversal, \symTotal}$ is afhankelijk van het aantal doorkruisingen $\symTraversalL_{\symInternal}$ van inwendige knopen.
    Formule \ref{eq:rendertijd} beschrijft dit wiskundig met $\symTime_{\symIntersection}$ de tijd nodig voor één straal-driehoek intersectie en $\symTime_{\symTraversal}$ de tijd nodig om één knoop te doorkruisen. 
\begin{equation}
    \label{eq:rendertijd}
   \symTime_{\symRender} \sim
    \symTime_{\symIntersection, \symTotal} + \symTime_{\symTraversal, \symTotal} = \symTime_{\symIntersection} * \sum_{\symLeaf}^\symLeafL \symNbPrimitives_\symLeaf * \symTraversalL_\symLeaf + \symTime_{\symTraversal} * \symTraversalL_{\symInternal}
\end{equation}

Stel dat één kindknoop $\symLeaf_j$ uit de boom wordt opgesplitst in twee kleinere kindknopen $\symLeaf_{j1}$ en $\symLeaf_{j2}$ die elk de helft van de driehoeken krijgen.
Deze opsplitsing is voordelig als aan voorwaarde \ref{eq:vw_splitwinst} voldaan is.
Deze voorwaarde drukt uit dat knoop $\symLeaf_j$ nu een inwendig knoop wordt en dus niet meer zorgt voor een intersectietijd en wel voor een doorkruistijd en dat de nieuwe kindknopen zorgen voor een intersectietijd.
De voorwaarde is equivalent aan voorwaarden \ref{eq:vw_splitwinst_tussen} en \ref{eq:vw_splitwinst_res}.
% B -> 2Bs : nb -> nb/2 * 2 en Db1 + db2 << Db + 1 inwendige knoop, Db keer bekeken
\begin{equation}
    \label{eq:vw_splitwinst}
    \symTime_{\symRender} - \symTime_{\symIntersection} * \symNbPrimitives_{\symLeaf_j} * \symTraversalL_{\symLeaf_j} + \symTime_{\symTraversal} * \symTraversalL_{\symLeaf_j}  + \frac{\symNbPrimitives_{\symLeaf_j}}{2} * (\symTraversalL_{\symLeaf_{j1}} + \symTraversalL_{\symLeaf_{j2}}) * \symTime_{\symIntersection} \leq \symTime_{\symRender}
\end{equation}
\begin{equation}
    \label{eq:vw_splitwinst_tussen}
  \Leftrightarrow \frac{\symNbPrimitives_{\symLeaf_j}}{2} * (\symTraversalL_{\symLeaf_{j1}} + \symTraversalL_{\symLeaf_{j2}}) * \symTime_{\symIntersection} \leq (\symTime_{\symIntersection} * \symNbPrimitives_{\symLeaf_j} - \symTime_{\symTraversal}) * \symTraversalL_{\symLeaf_j}
\end{equation}
%\begin{equation}
%    \frac{\symNbPrimitives_{\symLeaf_j} * \symTime_{\symIntersection}}{(\symTime_{\symIntersection} * \symNbPrimitives_{\symLeaf_j} - \symTime_{\symTraversal})} \leq \frac{2\symTraversalL_{\symLeaf_j}}{(\symTraversalL_{\symLeaf_{j1}} + \symTraversalL_{\symLeaf_{j2}}) }
%\end{equation}
%\begin{equation}
%    \frac{1}{(1 - \frac{\symTime_{\symTraversal}}{\symNbPrimitives_{\symLeaf_j} * \symTime_{\symIntersection}})} \leq \frac{2\symTraversalL_{\symLeaf_j}}{(\symTraversalL_{\symLeaf_{j1}} + \symTraversalL_{\symLeaf_{j2}}) }
%\end{equation}
\begin{equation}
    \label{eq:vw_splitwinst_res}
    \Leftrightarrow \symTraversalL_{\symLeaf_{j1}} + \symTraversalL_{\symLeaf_{j2}} \leq
    2\symTraversalL_{\symLeaf_j} * (1 - \frac{\symTime_{\symTraversal}}{\symNbPrimitives_{\symLeaf_j} * \symTime_{\symIntersection}})
\end{equation}

De som in het linkerlid van voorwaarde \ref{eq:vw_splitwinst_res} is minstens gelijk aan $\symTraversalL_{\symLeaf_{j}}$ aangezien elke doorkruising van $\symLeaf_j$ voor minstens één doorkruising door een kindknoop zorgt.
Analoog kan worden ingezien dat de maximale waarde voor deze som gelijk is aan $2\symTraversalL_{\symLeaf_{j}}$ aangezien elke doorkruising van $\symLeaf_j$ voor maximaal twee doorkruisingen door een kindknoop kan zorgen. Hieruit volgt ongelijkheid \ref{eq:vw_doorkruisingen}.

\begin{equation}
    \label{eq:vw_doorkruisingen}
    \symTraversalL_{\symLeaf_{j}} \leq \symTraversalL_{\symLeaf_{j1}} + \symTraversalL_{\symLeaf_{j2}} \leq 2\symTraversalL_{\symLeaf_{j}}
\end{equation}

In het algemeen geval geldt dat $\symTraversalL_{\symLeaf_{j1}} + \symTraversalL_{\symLeaf_{j2}} = (2 * (1-\alpha) + \alpha) \symTraversalL_{\symLeaf_{j}}$ waarbij $\alpha$ het procentueel aantal doorkruisingen is dat door slechts één van de twee kindknopen gaat.
In dit geval leidt voorwaarde \ref{eq:vw_splitwinst_res} tot voorwaarde \ref{eq:vw_splitwinst_general}.
\begin{equation}
    \label{eq:vw_splitwinst_general}
    (2 * (1-\alpha) + \alpha) \symTraversalL_{\symLeaf_{j}} \leq
    2\symTraversalL_{\symLeaf_j} - \frac{2\symTraversalL_{\symLeaf_j}\symTime_{\symTraversal}}{\symNbPrimitives_{\symLeaf_j} \symTime_{\symIntersection}}
    \Leftrightarrow
    2 - \alpha \leq 2 - \frac{2\symTime_{\symTraversal}}{\symNbPrimitives_{\symLeaf_j} \symTime_{\symIntersection}}
    \Leftrightarrow
    \symTime_{\symTraversal} \leq \frac{\alpha \symNbPrimitives_{\symLeaf_j} }{2}\symTime_{\symIntersection}
\end{equation}

In het ideale geval ($\alpha = 1$) leidt voorwaarde \ref{eq:vw_splitwinst_general} tot $\symTime_{\symTraversal} \leq \frac{\symNbPrimitives_{\symLeaf_j}}{2}\symTime_{\symIntersection}$.
Het opsplitsen van een knoop met twee elementen, kan hierdoor pas voordelig zijn als de doorkruistijd kleiner is dan de intersectietijd.
Aangezien de doorkruistijd in de realiteit beduidend kleiner is dan de intersectietijd, is het in dit ideale geval altijd voordelig om een kindknoop op te splitsen, ongeacht het aantal driehoeken in de knoop.
In het slechtste geval ($\alpha = 0$) kan aan voorwaarde \ref{eq:vw_splitwinst_general} enkel voldaan zijn als de doorkruistijd gelijk is aan nul. Dit is onmogelijk waardoor opsplitsen nooit voordelig kan zijn in dit geval. \\

Het is moeilijk om de waarde van $\alpha$ te voorspellen, deze is namelijk afhankelijk van de exacte stralen die tijdens het renderen gevolgd worden, de specifieke driehoeken in de knoop en het splitsingsvlak. Voorwaarde \ref{eq:vw_splitwinst_general} toont dat de kans dat splitsen voordelig is, lineair stijgt met $\symNbPrimitives_{\symLeaf_j}$. De voorwaarde toont ook dat het splitsen van een knoop met twee driehoeken, voordelig is wanneer de doorkruistijd $\alpha$ keer kleiner is dan de intersectietijd. Intuitief lijkt het logisch dat hier in het algemeen aan voldaan is. Hieruit kan worden afgeleid dat het altijd beter is om bladknopen met meer dan één driehoek op te splitsen in twee kleinere bladknopen. De volgende secties ... \\



\section{Algemeen idee}
    De $\symBSPsweep$ boom is een algemene $\symBSP$ boom waarbij in elke knoop k richtingen bepaald worden en alle $2n$ splitsingsvlakken langs elk van deze richtingen worden bekeken door te sweepen.
    Deze k richtingen kunnen verschillend zijn voor elke knoop en kunnen gekozen worden afhankelijk van de lokale geometrie.
    De $\symRBSP$ boom is een $\symBSPsweep$ boom waarbij de gekozen richtingen in elke knoop hetzelfde zijn.
    De $\symBSPsweep$ boom heeft drie belangrijke ontwerpbeslissingen.
    De belangrijkste ontwerpbeslissing bij de $\symBSPsweep$ boom is de methode die gebruikt wordt om de k richtingen te bepalen.
    Een tweede belangrijke ontwerpbeslissing is de waarde van k.
    De derde belangrijke ontwerpbeslissing sluit aan bij de eerst en gaat over het al dan niet gebruiken van de $\symKd$ richtingen als de eerste drie van de k richtingen.
    \\


    %Kd-richtingen + aantal richtingen of puur die richtingen
    %Snelle traversal voor kd-richtingen
\section{Gebaseerd op random richtingen}
De simpelste $\symBSPsweep$ bepaalt in elke knoop k random richtingen onafhankelijk van de geometrie.
De richtingen worden uniform op de hemisphere gegenereerd.
Het idee achter deze boom is dat het nuttiger kan zijn om driehoeken via veel verschillende vlakken te proberen splitsen, dan om ze steeds met dezelfde vlakken te proberen splitsen.
Als de driehoeken in de scene uniform verdeeld zijn, dan is de kans dat twee driehoeken volgens een willekeurige richting gesplitst kunnen worden, even groot als de kans dat ze door een $\symKd$ richting gesplitst kunnen worden.

Als de $\symBSPrandom$ boom perfect gebalanceerd is, worden in elk niveau $2kn$ verschillende splitsingsvlakken bekeken.
Deze splitsingsvlakken zijn verschillend op elk niveau, zodat in totaal $2knlog(n)$ verschillende splitsingsvlakken bekeken worden.
Figuur \ref{fig:splitsingsvlakken-bsprandom} toont dit visueel.
De $\symBSPrandom$ boom probeert elke driehoek via gemiddeld $2klog(n)$ ($\symO(log(n))$) vlakken te splitsen van de andere driehoeken, in tegenstelling tot de bestaande bomen die dit maximaal met $\symO(1)$ vlakken proberen.\\

\begin{figure}
    \centering

   \resizebox{0.4\textwidth}{!}{%
   \centering
    \begin{tikzpicture}
   \Tree
   [ .\node[fill=green]{$2kn$};    
       [.\node[fill=nodeblue1]{$2k\frac{n}{2}$};
           [.\node(n3l)[fill=nodered1, text=white]{$2k\frac{n}{4}$};]
           [.\node[fill=nodered2, text=white]{$2k\frac{n}{4}$};]
       ]
       [.\node[fill=nodeblue2, text=white]{$2k\frac{n}{2}$};
           [.\node[fill=nodered3, text=white]{$2k\frac{n}{4}$};]
           [.\node(n3r)[fill=nodered4, text=white]{$2k\frac{n}{4}$};]
       ]
   ]
   \node at (3,0.5) {$\#$};
   \node at (4,0.5) {$\# \neq$};
   \node at (3,0) {$2kn$};
   \node at (3,-1.5) {$2kn$};
   \node at (3,-3) {$2kn$};
   \node at (4,0) {$2kn$};
   \node at (4,-1.5) {$4kn$};
   \node at (4,-3) {$6kn$};
   \end{tikzpicture}
   }
   \caption[Splitsingsvlakken $\symBSPrandom$]%
    {Splitsingsvlakken $\symBSPrandom$ - \small Per niveau het aantal ($\#$) splitsingsvlakken en het totaal aantal verschillende ($\# \neq$) splitsingsvlakken gebruikt in bovenliggende niveaus bij de $\symBSPrandom$ boom.} %TODO: meer uitleg
    \label{fig:splitsingsvlakken-bsprandom}
\end{figure}

\begin{figure}
        \resizebox{\textwidth}{!}{%
        \centering
         \begin{tikzpicture}
            \usetikzlibrary{arrows}
            \usetikzlibrary{shapes}
\tikzstyle{every tree node}=[draw, ellipse, align=center]
        \Tree
        [ .\node[shading = axis, left color=green, right color=nodeyellow1,shading angle=135]{$2(k-3)n + 6n$};    
            [.\node[shading = axis, left color=nodeblue1, right color=nodeyellow1, shading angle=135]{$2(k-3)\frac{n}{2} + 6\frac{n}{2}$};
                [.\node(n3l)[shading = axis, left color=nodered1, right color=nodeyellow1, shading angle=135]{$2(k-3)\frac{n}{4} + 6\frac{n}{4}$};]
                [.\node[shading = axis, left color=nodered2, right color=nodeyellow1, shading angle=135]{$2(k-3)\frac{n}{4} + 6\frac{n}{4}$};]
            ]
            [.\node[shading = axis, left color=nodeblue2, right color=nodeyellow1, shading angle=135, text=white]{$2(k-3)\frac{n}{2} + 6\frac{n}{2}$};
                [.\node[shading = axis, left color=nodered3, right color=nodeyellow1, shading angle=135]{$2(k-3)\frac{n}{4} + 6\frac{n}{4}$};]
                [.\node(n3r)[shading = axis, left color=nodered4, right color=nodeyellow1, shading angle=135]{$2(k-3)\frac{n}{4} + 6\frac{n}{4}$};]
            ]
        ]
        \node at (10,0.5) {$\#$};
        \node at (13,0.5) {$\# \neq$};
        \node at (10,0) {$2(k-3)n + 6n$};
        \node at (10,-1.5) {$2(k-3)n + 6n$};
        \node at (10,-3) {$2(k-3)n + 6n$};
        \node at (13,0) {$2(k-3)n + 6n$};
        \node at (13,-1.5) {$4(k-3)n + 6n$};
        \node at (13,-3) {$6(k-3)n + 6n$};
        \end{tikzpicture}
        }
    \caption[Splitsingsvlakken $\symBSPrandomsomekd$]%
    {Splitsingsvlakken $\symBSPrandomsomekd$ - \small Per niveau het aantal ($\#$) splitsingsvlakken en het totaal aantal verschillende ($\# \neq$) splitsingsvlakken gebruikt in bovenliggende niveaus bij de $\symBSPrandomsomekd$ boom.} %TODO: meer uitleg
    \label{fig:splitsingsvlakken-bsprandomsomekd}
\end{figure}

De $\symKd$ richtingen zijn in praktische scenes vaak beter dan willekeurige richtingen omdat ze loodrecht op elkaar staan waardoor ze de hemisphere goed bedekken.
Dit geeft aanleiding tot een boom die als eerste drie richtingen steeds de $\symKd$ richtingen kiest en enkel de overige $k - 3$ richtingen random genereert: de $\symBSPrandomkd$ boom. Een extra voordeel is dat de snellere $\symKd$ knoop doorkruising gebruikt kan worden. Een boom die altijd de $\symKd$ richtingen gebruikt en de doorkruising van $\symKd$ knopen optimaliseert, wordt aangeduid als $\symBSPrandomfastkd$. 
Als de $\symBSPrandomsomekd$ boom perfect gebalanceerd is, worden in elk niveau $2kn$ splitsingsvlakken bekeken.
Van deze $2kn$ zijn er $6n$ die hergebruikt worden, de vlakken volgens de $\symKd$ richtingen.
Dit zorgt voor $2(k-3)n$ verschillende splitsingsvlakken per niveau, zodat in totaal $2(k-3)nlog(n) + 6n$ verschillende splitsingsvlakken bekeken worden.
Figuur \ref{fig:splitsingsvlakken-bsprandomsomekd} toont dit visueel.
De $\symBSPrandomsomekd$ boom probeert elke driehoek via gemiddeld $\symO(log(n))$ vlakken te splitsen van de andere driehoeken, net als  de $\symBSPrandom$ boom.\\


%(Extra) richtingen door random richtingen te kiezen
%Ter controle dat de richtingen met behulp van normalen, nuttige richtingen zijn
%Sweeping
%Waarom zou dit werken ? : Random per node itt vast bij Kd
%    Driehoeken proberen te worden gesplitst volgens meer verschillende richtingen, Kd probeert steeds hetzelfde
%    Kd heeft maar 3 opties, als het volgens geen kan -> nooit mogelijk
%    Kans splitsbaar door Kd richting of random is even hoog in uniform geval. Scenes hebben wel veel asgealigneerde delen, dus daarom die extra.

\section{Gebaseerd op geometrische normalen}
\subsection{Willekeurige normaal}
    Extra richtingen door random normalen te kiezen
    Autopartitie van Ize maar gesweeped
    Waarom zou dit werken ? : ...
    
\subsection{Geclusterde normalen}
    (Extra) richtingen via K-means clustering
    Sweepen volgens die richtingen
    Waarom zou dit werken ...

%\section{Hiërarchie}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "masterproef"
%%% End: 